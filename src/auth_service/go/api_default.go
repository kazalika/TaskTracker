/*
 * Пример API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"context"
	"errors"
	"fmt"
	"net/http"

	"auth/redis"
	"encoding/json"

	"github.com/golang-jwt/jwt/v5"
)

func GetUserData(username string, toSaveMap *map[string]string) (int, error) {
	rdb := redis.GetRedisClient()
	// Проверяем, существует ли пользователь в Redis
	storedUserDataJSON, err := rdb.Get(context.Background(), username).Result()
	if err != nil {
		return http.StatusUnauthorized, errors.New("user not found")
	}

	// Преобразуем JSON в структуру UserData
	storedUserData := make(map[string]string)
	err = json.Unmarshal([]byte(storedUserDataJSON), &storedUserData)
	if err != nil {
		return http.StatusInternalServerError, err
	}
	return 0, nil
}

func GenerateJWT(username string) (string, error) {
	han := redis.GetJWTHandlers()
	payload := jwt.MapClaims{
		"username": username,
	}
	token := jwt.NewWithClaims(jwt.SigningMethodRS256, payload)
	tokenString, err := token.SignedString(han.JwtPrivate)
	if err != nil {
		fmt.Println("Error signing token:", err)
		return "", err
	}
	return tokenString, nil
}

func StoreUserData(username string, data map[string]string) (int, error) {
	rdb := redis.GetRedisClient()
	// Преобразуем данные в JSON
	newUserDataJSON, err := json.Marshal(data)
	if err != nil {
		return http.StatusInternalServerError, err
	}
	// Сохраняем данные в Redis
	err = rdb.Set(context.Background(), username, newUserDataJSON, 0).Err()
	if err != nil {
		return http.StatusInternalServerError, errors.New("error in saving to DB")
	}
	return 0, nil
}

func CheckIfUserExists(username string) bool {
	rdb := redis.GetRedisClient()
	// Проверяем, существует ли пользователь в Redis
	_, err := rdb.Get(context.Background(), username).Result()
	return err == nil
}

func AuthenticatePost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	// Декодируем JSON из RequestBody в структуру Credentials
	var creds AuthenticateBody
	err := json.NewDecoder(r.Body).Decode(&creds)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Достаем данные пользователя из Redis
	storedUserData := make(map[string]string)
	code, err := GetUserData(creds.Username, &storedUserData)
	if err != nil {
		http.Error(w, err.Error(), code)
	}

	// Проверяем, совпадают ли пароли и есть ли в структуре вообще
	storedPassword, ok := storedUserData["password"]
	if !ok || storedPassword != creds.Password {
		http.Error(w, "Incorrect password", http.StatusUnauthorized)
		return
	}

	// Генерируем токен
	tokenString, err := GenerateJWT(creds.Username)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	// Сохраняем токен в Redis
	storedUserData["token"] = tokenString

	code, err = StoreUserData(creds.Username, storedUserData)
	if err != nil {
		http.Error(w, err.Error(), code)
	}

	// Устанавливаем токен в Cookie
	cookie := http.Cookie{
		Name:  "token",
		Value: tokenString,
	}
	http.SetCookie(w, &cookie)

	w.WriteHeader(http.StatusOK)
}

func RegisterPost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	// Декодируем JSON из RequestBody в структуру Credentials
	var creds RegisterBody
	err := json.NewDecoder(r.Body).Decode(&creds)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Проверяем пароль из Redis
	if CheckIfUserExists(creds.Username) {
		http.Error(w, "User with this Username does already exist", http.StatusBadRequest)
		return
	}

	// Генерируем токен
	tokenString, err := GenerateJWT(creds.Username)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	// Создаем данные для нового пользователя в Redis
	newUserData := map[string]string{
		"username": creds.Username,
		"password": creds.Password,
		"token":    tokenString,
	}
	code, err := StoreUserData(creds.Username, newUserData)
	if err != nil {
		http.Error(w, err.Error(), code)
	}

	// Устанавливаем токен в Cookie
	cookie := http.Cookie{
		Name:  "token",
		Value: tokenString,
	}
	http.SetCookie(w, &cookie)

	w.WriteHeader(http.StatusOK)
}

func UpdatePut(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	cookie, err := r.Cookie("jwt")
	if err != nil {
		http.Error(w, "No cookie", http.StatusUnauthorized)
		return
	}
	// Получаем доступ к ключам JWT
	han := redis.GetJWTHandlers()

	// Получаем токен из Cookie
	tokenString := cookie.Value
	payload := jwt.MapClaims{}
	token, err := jwt.ParseWithClaims(tokenString, &payload, func(token *jwt.Token) (interface{}, error) {
		return han.JwtPublic, nil
	})

	// Проверяем валидность токена
	if err != nil || !token.Valid {
		http.Error(w, "Invalid jwt token", http.StatusBadRequest)
		return
	}
	// Проверяем, что в токене есть поле username
	if _, ok := payload["username"]; !ok {
		http.Error(w, "Invalid payload in jwt token", http.StatusBadRequest)
		return
	}
	username := payload["username"].(string)

	// Достаем данные пользователя из Redis
	storedUserData := make(map[string]string)
	code, err := GetUserData(username, &storedUserData)
	if err != nil {
		http.Error(w, err.Error(), code)
	}

	// Проверяем, что токен из Cookie совпадает с токеном из Redis
	if v, ok := storedUserData["token"]; !ok || v != tokenString {
		http.Error(w, "The token has expired", http.StatusUnauthorized)
		return
	}

	// Достаем данные, которые нужно обновить
	var creds UpdateBody
	err = json.NewDecoder(r.Body).Decode(&creds)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Обновляем данные в Redis
	if creds.FirstName != "" {
		storedUserData["firstName"] = creds.FirstName
	}
	if creds.LastName != "" {
		storedUserData["lastName"] = creds.LastName
	}
	if creds.Birthday != "" {
		storedUserData["birthday"] = creds.Birthday
	}
	if creds.Email != "" {
		storedUserData["email"] = creds.Email
	}
	if creds.PhoneNumber != "" {
		storedUserData["phone"] = creds.PhoneNumber
	}

	code, err = StoreUserData(username, storedUserData)
	if err != nil {
		http.Error(w, err.Error(), code)
	}

	w.WriteHeader(http.StatusOK)
}
